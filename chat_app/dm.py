
# This file was generated by the Tkinter Designer by Parth Jadhav
# https://github.com/ParthJadhav/Tkinter-Designer


from pathlib import Path

# from tkinter import *
# Explicit imports to satisfy Flake8
from tkinter import Tk, Canvas, Entry, Text, Button, PhotoImage
import client
import select
import threading
import time
import json



def dm(chat_client: client.ChatClient, username: str, owner_username: str):

    def handle_incoming():
        while True:
            pause_event.wait()  # Wait if the pause event is set
            ready_to_read, _, _ = select.select([chat_client.out_socket], [], [], 0.1)
            if ready_to_read:
                chat_client.out_socket.setblocking(True)
                chat_client.handle_request()
                chat_client.out_socket.setblocking(False)



    OUTPUT_PATH = Path(__file__).parent
    ASSETS_PATH = OUTPUT_PATH / Path(r"assets/frame1")

    # Filter messages involving the specified username
    filtered_messages = [msg for msg in chat_client.messages if msg['from_user'] == username or msg['to_user'] == username]
    sorted_messages = sorted(filtered_messages, key=lambda x: x['timestamp'])


    def relative_to_assets(path: str) -> Path:
        return ASSETS_PATH / Path(path)


    window = Tk()

    window.geometry("1920x1080")
    window.configure(bg = "#FFFFFF")

    canvas = Canvas(
        window,
        bg = "#FFFFFF",
        height = 1080,
        width = 1920,
        bd = 0,
        highlightthickness = 0,
        relief = "ridge"
    )

    canvas.place(x = 0, y = 0)
    # bg rectangle
    canvas.create_rectangle(
        483.0,
        129.0,
        1437.0,
        952.0,
        fill="#332222",
        outline="")

    canvas.create_text(
        909.0,
        179.0,
        anchor="nw",
        text="DM\n",
        fill="#FFFFFF",
        font=("Inter", 60 * -1)
    )

    y_offset = 300  # Initial Y offset for displaying messages
    # Iterate over the last 20 messages (or less if there are fewer than 20 messages)
    # until i get pages working, or never teehee
    for message in sorted_messages[-20:]:
        text = f"{message['timestamp']} - {message['from_user']}: {message['message']}"
        canvas.create_text(
            600,
            y_offset,
            anchor="nw",
            text=text,
            fill="#FFFFFF",
            font=("Inter", 14)
        )
        y_offset += 30  # Increment Y offset to display next message

    # Function to refresh the display with updated messages
    def refresh_display():
        canvas.delete("all")  # Clear the canvas

        filtered_messages = [msg for msg in chat_client.messages if msg['from_user'] == username or msg['to_user'] == username]
        sorted_messages = sorted(filtered_messages, key=lambda x: x['timestamp'])
        canvas.place(x = 0, y = 0)
        # bg rectangle
        canvas.create_rectangle(
            483.0,
            129.0,
            1437.0,
            952.0,
            fill="#332222",
            outline="")

        canvas.create_text(
            909.0,
            179.0,
            anchor="nw",
            text="DM\n",
            fill="#FFFFFF",
            font=("Inter", 60 * -1)
        )

        y_offset = 300  # Initial Y offset for displaying messages
        for message in sorted_messages[-20:]:
            text = f"{message['timestamp']} - {message['from_user']}: {message['message']}"
            canvas.create_text(
                600,
                y_offset,
                anchor="nw",
                text=text,
                fill="#FFFFFF",
                font=("Inter", 14)
            )
            y_offset += 30  # Increment Y offset for the next message

    # Function to send the message when the button is clicked
    def send_message():
        message_text = message_entry.get()  # Get the text from the Entry widget
        if message_text == "":
            return
        # Clear the Entry widget after sending the message
        message_entry.delete(0, 'end')
        # Code to send the message using chat_client
        message = {
            "timestamp": time.strftime("[%Y-%m-%d %H:%M:%S]"),
            "message": message_text,
            "from_user": owner_username,
            "to_user": username
        }
        chat_client.messages.append(message)
        pause_event.set()
        chat_client.out_socket.setblocking(True)
        response = chat_client.post(username, message_text)
        chat_client.out_socket.setblocking(False)
        pause_event.clear()
        print(response)

        refresh_display()

    # Create an Entry widget for typing the message
    message_entry = Entry(window, font=("Inter", 12))
    message_entry.place(x=600, y=900)

    # Create a Button to send the message
    send_button = Button(window, text="Send", command=send_message)
    send_button.place(x=900, y=900)

    pause_event = threading.Event()

    # it was too tough doing blocking and non blocking so i gave in an did a 2nd thread... 
    incoming_thread = threading.Thread(target=handle_incoming)
    incoming_thread.daemon = True  # Set the thread as a daemon to exit with the main thread
    incoming_thread.start()

    def check_messages():
        last_displayed_message = message

        while True:
            time.sleep(1)  # Check every second
            chat_client.messages.sort(key=lambda x: x['timestamp'])  # Sort the messages

            # Get the last message after sorting
            last_message = chat_client.messages[-1]['message'] if chat_client.messages else ""

            # Check if the last message is different from the last displayed message
            if last_message != last_displayed_message:
                last_displayed_message = last_message
                refresh_display()  # Call the function to refresh the GUI

        


    # Start the thread to periodically check for new messages, without this, it only updates on sending a message
    check_messages_thread = threading.Thread(target=check_messages)
    check_messages_thread.daemon = True
    check_messages_thread.start()

    window.resizable(False, False)
    window.mainloop()
